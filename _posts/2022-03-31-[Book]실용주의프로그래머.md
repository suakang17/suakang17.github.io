---
layout: post
title:  "[책]실용주의 프로그래머"
date:   2022-03-31 20:20:26 +0900
categories: Devlife
---
 
# [책] 실용주의 프로그래머
w. 데이비드 토머스, 앤드류 헌트

## 읽기 전에
개발의 세계에 발을 들인지 오래 되지 않아 언제나 스스로의 코드가 부족하게 느껴졌다.  
누가 칭찬이라도 하면 겸언을 넘어서서 '저는 정말 아무것도 몰라요.' 라고 대답했다.  
그래서 스택도 스택이지만, 어떻게 하면 더 나은 개발자가 될 수 있는지 고민을 많이 하는 편이다.  

내가 보고 듣고 읽은 것들 중에서 공통적인 이야기는 책에는 돈을 아끼지 말라는 이야기였다.  
또 주위의 시니어와 이야기를 나누었을 때, 펼쳐보지 않은 책도 있지만, 개발자들 간 뜨거운 도서가 있으면 일단 사고 본다고 하셨다.   

내가 책을 자꾸 사는 이유는 아직 검증받고 싶어서인 것 같다.  
이런 방향으로 가는게 맞는지, 이런 마음가짐이 옳은지 등등    

책은 서점에 가서 꽂히면 그대로 구매하기도 하지만, 보통 다른 개발자들의 추천이나 입소문의 영향을 가장 많이 받는다.  
그런 점에서 '실용주의 프로그래머'는 요즘 내 주변에서 가장 뜨거운 책이다.  
처음엔 이미 가지고 있는 '클린 코드'와 표지가 똑같아 시리즈물인가 하고 넘겼었는데, 매번 다른 사람이 같은 책을 추천하니 책장에 꽂혀있는 '클린 코드'는 제쳐놓고 이 책을 주문해 읽기 시작했다.  

아직까지는 분명히 와닿지 않는 주제들도 있다.  
그런 주제들과 마주하면 정말 라디오를 듣듯 흘려넘기고 있다.  
그러면 나중에 같은 상황에 처했을 때 문득 생각이 나지 않을까 하는 마음가짐이다.  

책을 읽으며 와닿는 부분을 이 포스팅에 정리하려 한다.  
완독 후 내 개인적인 평도 남길 예정이다.  
아무튼 독서 시작!

## 1장 실용주의 철학
> 특정 기술에 메이면 안 된다. 개별 상황마다 그 상황에서 좋은 해결 방안을 고를 수 있도록 충분한 배경지식과 경험을 쌓아야 한다.

얼마 전 들은 조언과 똑같았다.  
"도구는 도구일 뿐 목적이 아니다. 우리의 목적은 그러한 도구를 활용해서 더 좋은 시스템을 만들려고 하는 것이고 특정 도구에만 매달리거나 매몰되면 안된다."

> 모든 과정에서, 매일, 내가 내리는 모든 결정을 비판적으로 평가하라.

습관적으로 생각하며 일하기! 난 기계가 아니다.  
그래도 가장 어렵지 않을까 싶다.

> 깨진 창문은 발견하자마자 고치고, 고칠 시간이 없으면 판자로 덮는 것 만이라도 하자.  
위기가 찾아왔다고 해서 부가적인 피해를 입히지 말자.

심리적인 이야기이기도 하다고 느꼈다.  
나도 코드 수정사항을 발견하고 방치했을 때, 방치할 수록 수정할 의욕이 떨어졌던 경험이 있다.  
뭐든 바로바로 하는게 만변의 진리인 듯
> 항상 큰 그림 보기.

테세우스의 배

> 모듈과 외부에 노출할 함수에는 주석을 달자. 주석의 목석은 코드의 용도와 목적을 논하는 것.

저번 학기에 들었던 파이썬 수업이 생각났다.  
어떻게 동작하는지는 코드가 이미 보여주므로 이에 대해 주석을 다는 건 사족이다.
## 2장 실용주의 접근법
> ETC 원칙: Easier to Change  

우리의 이해는 날마다 바뀐다.

> DRY 원칙: Don't Repeat Yourself

하나를 바꾸면 나머지도 바꿔야 함을 기억하기.

> 직교성: 하나가 바뀌어도 나머지에 어떤 영향도 주지 않는 경우  

설계가 직교적인지 확인하는 질문: 특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가?  
이 때 스스로 제어할 수 없는 속성에 의존하지 말자.

개발을 처음 접했을 때 작성했던 크롤링 코드가 생각났다.  
지정된 url로 접속하여 해당 페이지의 html 코드에서 몇가지 토큰을 가져오도록 하는 코드였는데, 당시 html을 잘 몰라 배워가며 작성하던 코드라 엉뚱한 데이터를 긁어오곤 했다.  
문제를 파악한 뒤에 그 데이터와 관련된 코드들을 대폭 뜯어고쳐야 했던걸 보면 전혀 직교성이라고는 찾아 볼 수 없던 코드였다.  

- 기술을 현명하게 선택하라.  
- 코드의 결합도를 줄여라.  
- 전역 데이터를 피하라.  
- 유사한 함수를 피하라.  

> 예광탄 코드 VS. 프로토타이핑

예광탄 코드: 시스템을 정의하는 중요한 요구 사항을 찾고, 의문이 드는 부분이나 가장 위험이 커보이는 곳을 찾아서 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.  

프로토타이핑의 목적: 전반적으로 시스템이 어떻게 동작할지에 대한 감 잡기. 세부사항 무시하기.  

예광탄 코드는 나중에 최종 시스템 골격의 일부 vs 프로토 타입은 나중에 버리는 코드  
## 3장 기본도구
> 셸로는 내 맞춤형 도구를 만들 수 있다.  

학부 리눅스 수업이 확실히 이를 체감하는데 도움이 되었다.  
파이프 사용법, 나만의 맞춤형 명령어 조합하기 등 여러가지를 쉽게 처리할 수 있었다.

> 어플리케이션 테스트의 경우 경계조건과 실사용자의 사용 패턴 모두를 테스트하기.  

passion timer 웹을 처음 완성했을 때, 안드로이드와 아이폰에 제공되는 환경이 달라 원인을 찾았던 기억이 난다. 미리미리 확인해두자.
> 버그를 수정하기 전, 다른 코드들로부터 분리해서 재현부터 하기.  

타 코드들로부터 분리해서 원인을 찾아내는 맥락이라고 느꼈다. 간혹가다 에러 메세지에 집착하다가 멀쩡했던 부분을 수정하고 정작 버그인 곳은 문제 없다고 생각했던 경우가 있다. 뭐가 문제인지 알고 나서 수정하기 시작하자.
> 잘못된 데이터가 나타나는 경우 디버거 이용+이진 분할 사용하여 원인 특정하기.  

## 4장 실용주의 편집증
> 계약에 의한 설계: 더도 덜도 않고 딱 본연의 작업만 하도록 문서화, 검증하는 것  

코드 작성 전, 유효한 입력 범위가 어떠한지, 경계 조건이 무엇인지 등을 나열하는 것 만으로도 도움이 됨

의미론적 불변식은 의미의 중심이 되어야 하며, 비즈니스 규칙 등 일시적 정책에 영향을 받으면 안됨

> 모든 케이스/스위치문에 디폴트 구문을 달아야 한다.  

'있을 수 없는 일'이 발생했을 때 그 사실을 알기 위함  
단정문을 사용하자: 문자욜로 꼭 설명 넣기
```
assert result != null && result.size() > 0 : "XYZ의 결과가 비어 있음";
```
여전히 알 수 없는 0과 1들의 세계에서 확실한 것은 아무것도 없다고 느껴진다.
나를 믿지 말고 차라리 0과 1을 믿자.  
> 하이젠버그: 디버깅 행위가 디버깅하려는 시스템의 행동을 바꿔버리는 문제  

> 리소스를 할당하는 함수, 객체가 리소스를 해제하는 책임 역시 져야 한다.

해제하지 않으면 해당 객체가 알 수 없는 길을 걷게 되겠지...
## 5장 구부러지거나 부러지거나
> 소프트웨어의 구조는 유연해야한다. -> 결합을 줄이자.

결합의 증상 
 - 관계없는 모듈, 라이브러리 간의 희한한 의존 관계  
 - 한 모듈의 간단한 수정이 시스템 전역으로 퍼지거나 다른 곳에 영향을 미치는 경우
 - 개발자가 코드의 수정을 두려워하는 경우

코드를 재사용할 수 있게 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다. -> 글로벌화의 해악

수정 가능한 외부 리소스는 모두 전역 데이터 -> 이 리소스를 내가 작성하는 코드로 모두 감싸기  
> 프로그램: 입력을 출력으로 바꾸는 것

## 6장 동시성
> 어느 프로세스도 자신이 보는 메모리가 일관되어 있음을 보장할 수 없다.

불규칙한 실패는 동시성 문제인 경우가 많음

## 7장 코딩하는 동안
> 왜 코드다 망가졌는지 모르는 까닭은 애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문

너무 뼈 아픈 한마디다. 능동적으로 생각하며 코드를 써야하는데 눈과 손에 익은 문제 없어 보이는 코드들을 자꾸 쓰게 된다. 생각하자!

    






 





