---
layout: post
title:  "[Study] 네트워크 스터디 4회차"
date:   2023-04-23 13:34:35 +0900
categories: Study
published: False
---

# [Study] 네트워크 스터디 4회차 : TCP

이 포스팅은 예상 질문과 그에 대한 제 답변으로, 오류가 있다면 알려주세요!

## TCP

---

### 질문과 답변

**TCP에 대해 설명해주세요.**

TCP(Transmission Control Protocol)는 인터넷 프로토콜(IP) 위에서 동작하는 전송 계층 프로토콜 중 하나로, 안정적인 연결 지향형 통신을 제공합니다. 

이 연결은 3-way handshaking과정을 통하기에 높은 신뢰성을 보장하지만 속도가 느립니다.
종료시에는 4-way handshakinig을 통해 연결을 해제합니다.

데이터를 세그먼트로 나누어 순서대로 전송하며, 수신측에서는 세그먼트를 재조합하여 데이터를 복원합니다. 데이터 전송 중에 발생할 수 있는 손실, 중복, 지연 등의 문제를 해결하기 위한 여러 기능을 제공하며, 특히 안정적인 전송을 보장하기 위해 흐름 제어, 혼잡 제어, 오류 제어 등을 지원합니다. 

또한 TCP는 대부분의 웹 브라우저에서 사용되는 HTTP 프로토콜의 기반이 되는 프로토콜로 알려져 있습니다.
    
**3 way handshake에 대해 설명해주세요.**

TCP 연결 설정 프로세스로, 클라이언트와 서버 간에 신뢰성 있는 연결을 설정하는 방법입니다.  

1. 먼저 클라이언트가 `SYN(Synchronize)` 패킷을 서버에 보냅니다. 
    이 패킷에는 랜덤한 초기 순차 번호(ISN)가 포함되어 있습니다. 
    
    + ISN이 난수인 이유?
        tcp connection을 맺을 때 사용하는 port는 유한한 범위를 가지기에 시간이 지나면 재사용되므로, 이전의 다른 tcp connection으로부터의 패킷으로 잘못 인식할 가능성을 최대한 줄이기 위해 난수로 설정합니다.  

    + 클라이언트는 SYN 을 보낸 뒤 SYN/ACK 응답을 기다리는 `SYN_SENT` 상태가 됩니다.  

2. 서버는 SYN 패킷을 받으면, `SYN+ACK(Synchronize + Acknowledge)` 패킷을 클라이언트에 보냅니다. 
    이 패킷에는 서버의 초기 순차 번호와 클라이언트의 ISN 값에 1을 더한 값이 포함되며, SYN과 ACK 플래그가 모두 설정됩니다.  

    + 서버는 패킷을 받기 전, `LISTEN`상태로 포트 서비스가 가능한 상태여야 하며, SYN+ACK 패킷을 보낸 후에는 `SYN_RECEIVED` 상태가 됩니다.  

3. 마지막으로 클라이언트는 서버에게 `ACK(Acknowledge)` 패킷을 보내 연결 설정을 확인합니다.  
    이 패킷에는 클라이언트의 ISN 값에 1을 더한 값과 서버의 ISN 값에 1을 더한 값이 포함되며, ACK 플래그가 설정됩니다.  

    + 연결이 이루어진 후 서버의 상태는 `ESTABLISHED` 가 됩니다.

3단계의 패킷 교환을 통해, 클라이언트와 서버는 연결 설정에 필요한 초기값(ISN)과 상대방이 패킷을 수신할 준비가 되어 있음을 확인하게 됩니다. 이후에는 데이터를 전송할 때, 각각의 패킷에는 서로의 순차 번호가 포함되어, 상대방이 패킷을 올바르게 수신하는지 확인합니다.

(서버, 클라이언트 모두 `CLOSED` &rarr `ESTABLISHED`의 상태 변화를 갖습니다.)  

<img src='/assets/img/docs/3wayhandshake.png' />  

**4 way handshake에 대해 설명해주세요.**

TCP 4-way handshake는 TCP 연결을 종료하기 위해 클라이언트와 서버 간에 수행되는 프로토콜입니다. 

1. 클라이언트는 먼저 서버에게 연결을 종료하겠다는 `FIN` 패킷을 보냅니다.  

2. 서버는 FIN 패킷을 받으면, 해당 연결에 더 이상 데이터가 없음을 나타내기 위해 `ACK` 패킷을 보냅니다. 그러나 미처 보내지지 않은 데이터가 있을 수 있으므로 일정 시간 동안 기다립니다. 이 상태를 `CLOSE_WAIT`이라고 부릅니다. 

3. 서버는 모든 데이터를 보냈으므로 연결을 종료하기 위해 `FIN` 패킷을 클라이언트에게 보냅니다.  

4. 클라이언트는 FIN 패킷을 받으면, 해당 연결에 대한 모든 데이터를 수신하였으므로 `ACK` 패킷을 보내고 연결을 종료합니다. 이 때, 서버로부터 미처 받지 못한 데이터가 있을 수 있으므로 클라이언트는 `TIME_WAIT` 상태가 되어 대기합니다.  

    - 서버는 ack를 받은 뒤 소켓을 닫고 closed 상태가 됩니다.
    - 클라이언트는 time_wait 만큼의 시간이 지나면 소켓을 닫고 closed 상태가 됩니다.

이렇게 4개의 패킷을 주고받으면 TCP 연결이 완전히 종료됩니다.

(서버, 클라이언트 모두 `ESTABLISHED` &rarr `CLOSED`의 상태 변화를 갖습니다.)

**Congestion control에 대해 설명해주세요.**

데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 이 때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 합니다. 이러한 네트워크상 패킷 손실과 대역폭 저하가 예상되는 상황을 방지하기 위해 전송 속도를 제어하는 기술이 혼잡 제어입니다.

혼잡 제어를 통해 네트워크 내의 패킷 수와 속도를 모니터링하여 네트워크의 혼잡 상태를 파악하고, 이에 따라 네트워크 상황에 따라 윈도우 크기를 조정하며, 패킷 전송 속도를 조절하는 등의 조치를 취합니다.  

### 혼잡 제어 기법  

1. AIMD (Additive Increase Multicative Decrease)
    송신 측이 transmission rate(window size)를 패킷 손실이 일어날 때까지 1씩 증가시키는 식의 접근법

    - additive increase : 송신 측의 window size를 손실을 감지할때까지 매 RTT 마다 1 MSS씩 증가시킨다.  

    - multiplicative decrease : 손실을 감지했다면 송신측의 window size를 절반으로 감소시킨다.  

    AIMD는 window size를 1MSS씩 밖에 증가시키지 않기 때문에 네트워크의 모든 대역을 활용하여 빠른 속도로 통신하기까지 시간이 오래 소요됩니다. 또한 네트워크가 혼잡해질 상황을 미리 감지하지 못하고 혼잡해진 뒤에 대역폭을 줄이는 방식입니다.

2. Slow Start
    패킷이 문제 없이 도착하는 경우 window size를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 window size를 1로 줄이는 방식  

    전송한 데이터에 대한 ACK가 도착할 때마다 window size를 증가시키기 때문에 처음에는 window size가 조금 느리게 증가할지라도, 시간이 가면 갈수록 window size가 점점 빠르게 증가합니다.

    이 때, Treshold가 존재하는데 해당 지점까지만 Slow Start를 적용하겠다는 문턱값입니다.
    이 Treshold(ssthresh)에 도달하면 혼잡 회피 모드에 진입합니다.

3. Congestion Avoidance
    window size가 선형적으로 증가하는데, 타임아웃이 발생하면 윈도우 크기를 1로 초기화 하고 새로 Slow Start를 시작합니다. 3개의 중복 ACK가 검출되면 ssthresh 를 갱신하고 Fast Recovery 모드로 진입합니다.

4. Fast Recovery (빠른 회복)
    혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄인 뒤 선형증가시키는 방법

5. Fast Retransmit (빠른 재전송)
    중복된 순번의 패킷을 3개 받으면 재전송합니다. 혼잡한 상황이 발생한 것이므로 혼잡을 감지하고 window size를 줄입니다.  

**Flow control에 대해 설명해주세요.**

흐름 제어(Flow Control)란, 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법입니다.

송신 측의 속도가 빠를 경우 문제가 되는데, 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 되므로 이를 방지하기 위함입니다.  

TCP는 흐름 제어를 위해 Stop-n-Wait과 Sliding Window 기법을 사용합니다.  

Stop-n-Wait은 매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법으로 패킷을 하나씩 보내기 때문에 비효율적입니다.  

Sliding Window는 송신 측에서 수신 측으로 보내는 데이터의 양을 제어하는 메커니즘입니다.
TCP에서는 수신 측에서 수신 가능한 window size를 선언하고, 송신 측에서는 이 값을 확인하고, 여기에 맞춰 데이터를 전송합니다. 이를 통해 송수신 간의 데이터의 흐름이 일정하게 조절됩니다.

최초의 window size는 호스트들의 3-way handshake를 통해 수신 측 window size로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변합니다. window size는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아 보내집니다.  

[참고하면 좋을 글](https://steady-coding.tistory.com/507)