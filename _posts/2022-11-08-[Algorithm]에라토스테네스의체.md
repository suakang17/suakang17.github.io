---
layout: post
title:  "소수 판별 알고리즘"
date:   2022-11-08 12:01:57 +0900
categories: Study
published: False
---
# [Algorithm] 소수 판별 알고리즘

에라토스테네스의 체는 가장 대표적인 소수 판별 알고리즘으로, 백준 1929에서 처음 접했다.
<br><br>
소수는 오직 1과 자신만을 약수로 가지는 수이다.

## 시간복잡도 O(N)
여지껏 소수 판별 문제를 풀어올 때는 주어진 수 a에 대하여 2부터 a(a >= 2)의 범위를 반복하며 나누어 떨어지는 수가 있는지 확인하는 식으로 해결했었다. (아래 1978번을 그렇게 풀었다.)

```
# 백준 1978
N = int(input())
l = list(map(int, input().split()))
for i in l:
    if i == 1:
        N -= 1
    for j in range(2, i):
        if i % j == 0:
            N -= 1
            break
print(N)
```

그런데 1929번 문항에서 입력값의 범위가 최대 1,000,000까지 늘어나며 시간 복잡도가 O(N)인 해당 풀이로는 시간 초과가 떴다.
<br><br>
여기서 에라토스테네스의 체를 적용하면 시간 복잡도 O(NloglogN) 내에 해결할 수 있다.
<br><br>

## 시간 복잡도 O(sqrt(N))
우선 소스를 보면 다음과 같다.

```
# 1929번 정답 소스
m, n = map(int, input().split())

for i in range(m, n+1):
    if i == 1:
        continue
    for j in range(2, int(i**0.5)+1):
        if i % j == 0:
            break
    else:
        print(i)
```

i에는 소수인지 아닌지 판별할 수가 담기고, j는 원래 소스에서 2부터 i까지 나눌 수가 담긴다.

즉, 소수인지 판별할 수의 제곱근까지만 나누어보게 되는 것이다.
<br><br><br>
단순하게 이유를 설명하면, 약수는 대칭으로 이루어져있기 때문이다.

예를 들어 12의 약수는 1, 2, 3, 4, 6, 12가 있고, 
이는 12 = 1x12, 2x6, 3x4로 나타낼 수 있다.
각 곱셈쌍은 제곱근 12보다 큰 수, 작은 수의 구성만 가능하다.

즉, a = sqrt(a) x sqrt(a) 일 때, a = b x c (b < c) 라면, b와 c는 제곱근 a보다 모두 크거나, 모두 작을 수 없다. (제곱근을 기준으로 수의 크기가 대칭이다.)

b와 c의 곱이 a일 때, a를 b로 나누었을 때 c로 나누어 떨어지면, 역으로 a를 c로 나누면 b로 나누어 떨어진다는 것은 자명하다.

그리고 b와 c는 a의 제곱근을 기준으로 대칭이므로, 굳이 제곱근 a보다 큰 c로도 나누어 떨어지는 것을 확인할 필요가 없는 것이다.
<br><br>
증명은 잘 정리해주신 포스팅이 있어 확인할 수 있었다.
참고 링크로 남긴다.  
<br>
[[참고] 증명 링크](https://nahwasa.com/entry/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4-%ED%98%B9%EC%9D%80-%EC%86%8C%EC%88%98%ED%8C%90%EC%A0%95-%EC%8B%9C-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%EA%B9%8C%EC%A7%80%EB%A7%8C-%ED%99%95%EC%9D%B8%ED%95%98%EB%A9%B4-%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)
<br><br>
이 경우, 판별해야 할 수가 1,000,000이 넘어가는 경우, 제한사항에 따라 런타임에러가 뜰 수 있다.
## 시간 복잡도 O(NloglogN) (에라토스테네스의 체)

에라토스테네스의 체는 여러 개의 수가 주어졌을 때, 이 수들이 소수인지 아닌지 판별하는 알고리즘이다.

### N보다 작거나 같은 소수 찾기 과정
1. 2 ~ N의 자연수 나열
2. 1에서 아직 처리하지 않은 가장 작은 수 i 찾기
3. 처리하지 않은 수들 중 i를 제외한 i의 배수 모두 제거
4. 2 ~ 3번 과정의 반복

과정을 거쳐 남은 수가 N보다 작거나 같은 소수들이다.