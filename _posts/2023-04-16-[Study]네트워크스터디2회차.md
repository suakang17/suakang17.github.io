---
layout: post
title:  "[Study] 네트워크 스터디 2회차"
date:   2023-04-16 13:55:25 +0900
categories: Study
published: False
---

# [Study] 네트워크 스터디 2회차 : HTTP/HTTPS와 DNS

이 포스팅은 예상 질문과 그에 대한 제 답변으로, 오류가 있다면 알려주세요!

## HTTP

---

### 질문과 답변

**HTTP 프로토콜이 무엇인가요?**

HTTP는 웹 서버와 클라이언트 간의 통신에 사용되는 프로토콜로, 인터넷을 통해 웹 페이지 및 자원을 요청하고 전송하는 것을 담당합니다. 
HTTP는 클라이언트-서버 모델을 사용하며, 어플리케이션 레벨의 프로토콜로, TCP 프로토콜 위에서 동작하며 80번 포트를 사용합니다.
또한, 상태를 가지고 있지 않는 Stateless 프로토콜로, Method, Path, Version, Headers, Body 등으로 구성됩니다. 

**HTTP의 요청/응답 모델에 대해 설명해주세요.**

HTTP의 요청/응답 모델은 클라이언트가 서버로 요청을 보내면, 서버는 이에 대한 응답을 클라이언트에게 보내는 방식입니다. 요청은 일반적으로 메소드(GET, POST, PUT 등), URL, 그리고 헤더(header) 등을 포함합니다. 그 다음 서버는 요청을 처리하고, 성공 또는 실패에 따라 상태 코드(status code)를 포함한 응답, 응답 정보를 담은 헤더, 그리고 데이터를 포함한 본문(message body)을 클라이언트로 보내게 됩니다. 

[추가] 요청/응답 흐름  
브라우저에 URL을 입력하는 순간부터 HTTP 요청이 시작됩니다. 브라우저는 URL 값을 파싱하고 HTTP 요청 메시지(패킷)를 만들어 웹 서버로 전송합니다. 이 때, 라우팅은 도메인 이름이 아닌 IP 주소를 이용하므로 여기서 DNS가 작용합니다.
패킷이 웹 서버에 도착하면 패킷의 메시지를 복원 후 WAS에 넘기고, 해당하는 응답 데이터를 찾아 응답 패킷에 넣어 클라이언트에 보냅니다. 클라이언트 측이 응답을 수신하면 끝이 납니다.

[참고하면 좋을 글](https://deep-wide-studio.tistory.com/213)
    
**HTTP 메서드중 GET과 POST의 차이점은 뭔가요?**

GET 메서드는 정보 검색 및 조회에 사용되고, POST 메서드는 정보 제출에 사용됩니다.

GET 메서드는 서버로부터 **정보를 요청**하는 메서드입니다. 쿼리 문자열을 통해 요청된 리소스에 대한 정보를 검색하고, 서버에서는 요청된 정보를 URL에 첨부하여 응답합니다. GET 메서드는 브라우저의 캐시를 사용하므로, 이전에 요청한 내용과 동일한 요청이면 서버로부터 정보를 받아오지 않고, 캐시에서 정보를 가져와 처리합니다.

반면, POST 메서드는 서버에 **리소스를 제출**하는 메서드입니다. 요청된 데이터를 서버로 전송하며, POST 요청은 보안적으로 안전한 방식으로 전송됩니다. 또한, POST 메서드는 요청된 데이터를 본문에 담아 서버로 전송하므로, URL에 정보가 노출되지 않습니다.
    
**PUT과 PATCH의 차이점은 뭘까요?**

PUT과 PATCH 메소드는 모두 데이터를 업데이트하는 방법입니다. 
하지만 두 메소드는 목적과 작동 방식에서 차이가 있습니다.
PUT은 전체 리소스를 교체하거나 새로 생성하는 경우에 사용하고, PATCH는 리소스의 일부를 업데이트하는 경우에 사용합니다.

PUT 메소드는 전체 리소스를 업데이트합니다. 즉, 멱등성을 보장한다.
클라이언트가 서버로 리소스 전체를 전송하면, 서버는 해당 리소스를 요청 URI에 저장하거나 업데이트합니다. 만약 해당 엔티티가 없으면 새로운 엔티티를 생성합니다. 
이 방식은 전송한 데이터가 요청 URI의 리소스와 정확히 일치하도록 보장합니다.

반면 PATCH 메소드는 리소스의 일부분만 업데이트합니다. 따라서 멱등성을 보장하지 않는다.
클라이언트가 서버로 업데이트하려는 일부분만 전송하면, 서버는 해당 엔티티의 해당 부분을 업데이트합니다. 이 방식은 전체 리소스를 전송하지 않아도 된다는 점에서 PUT보다 효율적입니다. 그러나 리소스의 일부분만 업데이트하면서 리소스 전체의 일관성을 보장하기 위해서는 추가적인 로직이 필요합니다.
    
**HTTP 상태 코드가 뭔가요? 알고 있는 상태 코드 몇가지 알려주세요.**

HTTP 상태 코드는 HTTP 요청에 대한 응답으로 반환되는 숫자로, 요청이 성공했는지 실패했는지, 실패한 경우에는 그 이유가 무엇인지 등을 알려줍니다. 따라서 HTTP 상태 코드는 웹 개발에서 디버깅과 에러 해결에 중요한 역할을 합니다.

상태 코드는 3자리 숫자로 구성되며, 첫 번째 숫자는 응답의 일반적인 성격을 나타냅니다. 1xx 코드는 정보를 전달하기 위한 것이며, 2xx 코드는 성공적인 요청을 나타냅니다. 3xx 코드는 리다이렉션을 나타내며, 4xx 코드는 클라이언트 오류를 나타내고, 5xx 코드는 서버 오류를 나타냅니다.

가장 일반적으로 보게 되는 상태 코드는 200(OK)으로, 이는 요청이 성공적으로 처리되었음을 나타냅니다. 또한 404(Not Found) 상태 코드는 요청한 리소스가 서버에서 찾을 수 없는 경우 반환됩니다.

**HTTP 헤더가 뭘까요? 알고 있는 헤더 몇 가지 설명해주세요.**

HTTP 헤더는 HTTP 요청/응답에 필요한 모든 부가정보를 담고 있는 부분으로, 메시지 바디의 내용, 크기, 압축, 인증, 요청 클라이언트, 서버 정보 등이 포함되며 키-값 쌍으로 구성됩니다. 

종류는 다음과 같습니다.  

    - 공통헤더(General Header): 요청 및 응답 메시지 모두에서 사용 가능한 기본적인 헤더  

        ex. Date(메시지 생성 일시), Connection, Cache-Control  

    - 요청헤더(Request Header): HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 HTTP 헤더  

        ex. Host, Cookie  

    - 응답헤더(Response Header): 위치 또는 서버 자체에 대한 정보(이름, 버전)과 같이 응답에 대한 부가적인 정보를 갖는 헤더  

        ex. Server, Set-Cookie  

    - 엔티티헤더(Entity Header): Entity Body(컨텐츠, 본문, 리소스 등)에 대한 자세한 정보를 포함하는 헤더  

        ex. Content-Type, Content-Length  
    
**HTTP의 무상태성(Stateless)에 대해서 설명해주세요.**

무상태성은 클라이언트와 서버 간의 통신에서 이전에 발생한 모든 요청/응답과 관련된 정보를 기억하지 않음을 의미합니다. 즉, 이전 요청/응답이 현재 요청/응답에 영향을 주지 않습니다.

무상태성의 이점은 다음과 같습니다.  

    1. 서버에서 상태 정보를 유지하고 관리하는 것이 필요 없으므로 서버의 부담을 줄일 수 있다.  

    2. 서버와 클라이언트 간의 상태 정보 전달이 필요 없으므로 불필요한 대역폭 사용을 줄일 수 있다.  
    
    3. 클라이언트와 서버 간의 연결이 간단하고 투명하게 유지되므로 애플리케이션의 확장성을 향상시킬 수 있다.

그러나 사용자가 로그인 정보를 입력한 후 웹 페이지를 탐색할 때마다 로그인 정보를 다시 입력해야 하는 등의 상황에서 번거롭습니다. 이러한 문제를 해결하기 위해 쿠키(cookie)와 같은 기술을 사용하여 클라이언트와 서버 간의 상태 정보를 유지합니다.
    
**HTTP Keep-Alive에 대해서 설명해주세요.**

본래 HTTP는 connectionless방식으로 연결을 매번 끊고, 새로 생성하는 구조인데 Keep-Alive를 통해 연속된 요청에는 이미 연결되어 있는 TCP 연결을 재사용하는 기능입니다. 따라서 TCP/IP는 접속까지의 대기 시간이 줄어들게되고, 통신 처리량이 많아져 성능이 향상됩니다.
    
[참고하면 좋을 글](https://goodgid.github.io/HTTP-Keep-Alive/)

**HTTP 파이프라이닝에 대해서 설명해주세요.**

최초의 요청이 완료되기 전에 다음 요청을 보내는 기술로, 다음 요청까지의 대기 시간을 없앰으로써 성능을 향상시킵니다. Keep-Alive 이용을 전제로 하며, 서버는 요청이 들어온 순서대로 응답을 반환합니다.
    
**HTTP/1.1, HTTP/2, HTTP/3 각각의 특징에 대해 설명해주세요.**

- HTTP/1.1은 가장 많이 사용되고 있는 프로토콜로 connection 하나당 하나의 요청을 처리하도록 설계되어있기에 요청/응답을 순차적으로 처리합니다.
- HTTP/2는 HTTP/1.1의 성능을 개선한 버전입니다. connection 한개로 동시에 여러개의 요청을 처리합니다. 이 때, 응답은 순서에 상관없이 stream으로 주고 받습니다. 
- HTTP/3은 기존의 HTTP/1, /2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜입니다. 
    
**HTTP에서 캐싱을 구현하는 방법에는 어떤 것들이 있나요?**

모든 브라우저에서는 웹 문서의 임시 저장을 위한 HTTP 캐시(웹 캐시)의 구현을 제공합니다. 이 때, HTTP 헤더 지시문을 통해 브라우저가 응답을 캐싱할 수 있는 시기, 지속 기간을 지시합니다.

[참고하면 좋을 글](https://goddaehee.tistory.com/171)

## HTTPS

---

### 질문과 답변

**HTTPS에 대해서 설명해주세요.**

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. 암호화에는 대칭키, 비대칭키가 모두 사용됩니다.
    
**SSL/TLS이 뭔가요?**

SSL (Secure Sockets Layer)와 TLS (Transport Layer Security)은 인터넷 상에서 데이터를 안전하게 전송하기 위한 프로토콜로, 데이터 암호화와 인증(Handshake), 전자서명을 통해 통신 과정에서 발생하는 공격을 방지합니다.
(즉, 암호화 기반 인터넷 보호 프로토콜입니다.)

SSL/TLS를 사용하는 웹사이트 URL은 HTTP 대신 HTTPS가 사용됩니다.
SSL은 오래 전에 개발되었으며 TLS는 보다 안전한 업데이트 버전으로, 현재 대부분의 웹 브라우저와 웹 서버는 TLS를 사용하며, SSL은 더 이상 권장되지 않습니다. 
    
**HTTPS 암호화 과정에 대해 설명해주세요. (SSL 핸드셰이크에 대해 설명해주세요.)**

HTTPS 암호화는 HTTPS 웹에 처음 커넥션 할 때 진행되며 SSL/TLS Handshake를 통합니다.
Handshake의 단계는 클라이언트/서버에서 지원하는 암호화 알고리즘에 따라 달라지는데 일반적으로 RSA 키 교환 알고리즘이 사용됩니다.

과정은 다음과 같습니다.

1. 클라이언트가 서버에 접속하여 HTTPS를 요청합니다.
2. 서버는 인증서를 클라이언트에게 보내주고, 이를 확인합니다. 인증서에는 서버의 공개키가 포함되어 있습니다.
3. 클라이언트는 서버의 인증서를 검증하고, 클라이언트가 생성한 대칭키를 사용하여 서버의 공개키를 암호화하여 서버에게 보냅니다.
4. 서버는 자신의 비밀키로 클라이언트가 보낸 대칭키를 복호화합니다.
5. 이제 서버와 클라이언트는 동일한 대칭키를 가지고 통신을 시작합니다. 이 키는 암호화 및 복호화에 사용됩니다.

[참고하면 좋을 글](https://kanoos-stu.tistory.com/46) 

## DNS

---

### 질문과 답변

**DNS가 뭔가요?**

DNS란 도메인 이름 시스템(Domain Name System)으로, 인터넷에서 호스트 이름과 IP 주소를 매핑하는 시스템입니다. 사용자가 웹 브라우저에서 도메인 이름을 입력하면, DNS는 해당 도메인 이름에 대한 IP 주소를 찾아서 사용자의 컴퓨터에게 반환합니다. 이를 통해 사용자는 도메인 이름을 이용하여 웹 사이트에 접근할 수 있게 됩니다.  
    
**DNS 작동 방식에 대해 설명해주세요.**

브라우저에서 도메인 이름을 입력하면 로컬 DNS 캐시에서 IP 주소를 찾습니다. 로컬 캐시에 해당 정보가 없으면 먼저 루트 DNS 서버를 찾습니다. 루트 DNS 서버는 해당 도메인 이름의 최상위 도메인 서버의 IP 주소를 제공하며, 클라이언트는 이를 찾아가며 그 다음 수중의 DNS 서버로 이동하여 IP 주소를 찾습니다. 최종적으로 해당 IP 주소를 로컬 DNS 캐시에 저장하여 이후에 더 빠른 검색을 가능하게 합니다.
    
**DNS 질의 종류에 대해 설명해주세요.**

DNS 쿼리는 재귀(Recursive), 반복(Iterative)로 구분되며, Locan DNS server에는 재귀, Root, TLD server에는 반복, Authoritative 서버에는 재귀/반복이 모두 사용됩니다.

Recursive 쿼리는 클라이언트가 요청한 질문에 대한 완전한 답변을 찾을 때까지 여러 DNS 서버에 쿼리를 전달하고 모든 답변을 클라이언트에게 반환합니다. 

Iterative 쿼리는 클라이언트가 요청한 질문에 대한 부분적인 답변만 DNS 서버에 요청하고, 해당 서버가 질문에 대한 부분적인 답변을 반환합니다. 클라이언트는 이 답변을 기반으로 다음 쿼리를 실행할 DNS 서버를 결정하고 질의를 계속합니다.

[참고하면 좋을 글](https://codybuilder.com/35)